<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CS349 WatGUI: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CS349 WatGUI
   &#160;<span id="projectnumber">2014.01</span>
   </div>
   <div id="projectbrief">WatGUI X lib Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CS349 WatGUI Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#docs">Making The Documentation</a></li>
<li class="level1"><a href="#intro">The WatGUI Toolkit: Overview</a></li>
<li class="level1"><a href="#finishing">Finishing the WatGUI Toolkit</a></li>
<li class="level1"><a href="#logging">Logging</a><ul><li class="level2"><a href="#logging_in_code">Logging in Code</a></li>
<li class="level2"><a href="#logging_levels">Logging Levels</a></li>
<li class="level2"><a href="#logging_config">Enabling Logging at Runtime and Specifying Which Files to Log</a></li>
<li class="level2"><a href="#logging_marking">Logging Level for Assignment Marking</a></li>
<li class="level2"><a href="#logging_scheme">Setting Logging Levels via Scheme</a></li>
</ul>
</li>
<li class="level1"><a href="#unit_tests">Unit Tests</a><ul><li class="level2"><a href="#adding_unit_tests">Adding Unit Tests to the Build Process</a></li>
</ul>
</li>
<li class="level1"><a href="#makefile">Makefile and Adding Files</a></li>
<li class="level1"><a href="#scheme">Scheme Interpreter</a></li>
<li class="level1"><a href="#scheme_scripts">Adding Scheme Scripts</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="docs"></a>
Making The Documentation</h1>
<p>Type: </p>
<pre class="fragment">make docs
</pre><p>to create and view this documentation in the <code>docs/</code> directory. This will create documentation for this file and the API.</p>
<p>Once the documentation has been generated, open the <code>index.html</code> file in the <code>docs/html/</code> directory. Use the <a href="./annotated.html">Classes</a> and <a href="./files.html">Files</a> buttons up top to view the API documentation. The <a href="./hierarchy.html">Class Hierarchy</a> is also useful.</p>
<p>We use doxygen to create the documentation, and have set documentation generation to be very verbose. The documentation for every function includes the actual code within the documentation, along with links to its definition in the source code, and links to functions it references and that reference it. You are free to adjust this verbosity: Edit doxygen.cfg to suit your tastes.</p>
<h1><a class="anchor" id="intro"></a>
The WatGUI Toolkit: Overview</h1>
<p>The WatGUI toolkit is a very basic X11-based graphical user interface (GUI) toolkit. The intent of the toolkit is to give you an opportunity to learn about the internals of a GUI toolkit through a relatively small code base.</p>
<p>The toolkit also demonstrates how to integrate a scripting engine with an application. We have tightly integrated TinyScheme, a very small Scheme interpreter with the toolkit. Briefly, the Scheme interpreter allows you to directly interact with the running application, creating new components on-the-fly, or adjusting existing components' attributes. More documentation about the Scheme integration can be found below.</p>
<h1><a class="anchor" id="finishing"></a>
Finishing the WatGUI Toolkit</h1>
<p>The provided toolkit will compile, but is incomplete. You need to complete the toolkit's missing parts for it to run correctly.</p>
<p>The parts that need to be completed are clearly marked in the source code. Search for "TODO" comments that include "CS349". These parts are also marked with TODO logging comments.</p>
<p>The missing parts of the toolkit include comments and hints to help you complete the missing code. The included unit tests will also help you validate and verify the toolkit is working as expected.</p>
<p>At present, you will need to fill in parts in:</p>
<ul>
<li><code><a class="el" href="Component_8cpp.html">Component.cpp</a></code></li>
<li><code><a class="el" href="EventQueue_8cpp.html">EventQueue.cpp</a></code></li>
<li><code><a class="el" href="PaintEvent_8cpp.html">PaintEvent.cpp</a></code></li>
<li><code><a class="el" href="XApplication_8cpp.html">XApplication.cpp</a></code></li>
</ul>
<h1><a class="anchor" id="logging"></a>
Logging</h1>
<p>This project uses <a href="http://google-glog.googlecode.com/svn/trunk/doc/glog.html">Google's logging library for logging</a>.</p>
<p>To use the library, add </p>
<pre class="fragment">#include "Logging.h"
</pre><p>to your C++ code.</p>
<h2><a class="anchor" id="logging_in_code"></a>
Logging in Code</h2>
<p>We're using the library's verbose logging features to help manage logging. If you open <code><a class="el" href="Logging_8h.html">Logging.h</a></code>, you'll notice the following macros are defined:</p>
<ul>
<li><code>LOG_TODO</code></li>
<li><code>LOG_PAINT</code></li>
<li><code>LOG_DEBUG</code></li>
<li><code>LOG_INFO</code></li>
<li><code>LOG_WARN</code></li>
<li><code>LOG_ERROR</code></li>
<li><code>LOG_FATAL</code></li>
</ul>
<p>To log something, use normal C++ streams operators. For example: </p>
<pre class="fragment">LOG_DEBUG &lt;&lt; "Value returned: " &lt;&lt; value;
</pre><p>Note that you don't need an <code>endl</code> at the end of the logging comment.</p>
<h2><a class="anchor" id="logging_levels"></a>
Logging Levels</h2>
<p>Google's logging library has two basic forms of logging macros, the "normal" logging macro (<code>LOG(level)</code>) and the verbose logging macro (<code>VLOG(level)</code>). The verbose logging macro provides greater flexibility in terms of controlling what log messages are output at runtime, so we use it for the TODO, paint, debug, info, and warning levels. More information about how to control what is output is provided in a section below.</p>
<p><code>LOG_TODO</code> logs sections of the toolkit that need to be implemented by you. <code>LOG_PAINT</code> logs painting operations to debug drawing to the screen. <code>LOG_ERROR</code> and <code>LOG_FATAL</code> are used to log unexpected states of the running application.</p>
<p><b>When logging messages for your own benefit (i.e., during development and during debugging), you should only use macros that use the VLOG macros</b> (such as <code>LOG_PAINT</code>, <code>LOG_TODO</code>, <code>LOG_DEBUG</code>, <code>LOG_INFO</code>, and <code>LOG_WARN</code>, or ones you define using VLOG). Using these macros allows you to keep logging comments in your code when submitting it because we can execute your binary with these logging messages disabled (as described below).</p>
<p>Error and fatal levels can also be inserted in your code, but should only be used for true error/fatal conditions. These <em>will</em> be output during marking. <em>Furthermore, LOG_FATAL messages will forcibly terminate the application with a core dump, so use with care.</em></p>
<p>You are free to define new levels of logging for your own purposes &ndash; use the debug, info, and warn macros as templates. Any new logging levels you define using the VLOG macro will not be output during marking.</p>
<h2><a class="anchor" id="logging_config"></a>
Enabling Logging at Runtime and Specifying Which Files to Log</h2>
<p>To output log messages, you need to set an environment flag corresponding to the minimum logging level you wish to use. main.cpp specifies that all logging messages should be output to stderr.</p>
<p>To output all log messages at the TODO level or lower (where "TODO" marks all the "to-do" points in the code), start the app from the command line like this: </p>
<pre class="fragment">GLOG_v=70 ./watgui
</pre><p><code>LOG_TODO</code> is mapped to verbose logging level 70, so by setting the Google logging flag "v" to 70, it ensures all to-do messages (and all other log messages with lower logging levels, including paint and debug messages) are logged.</p>
<p><em>For your convenience, we have defined the shell script <code>debug_app.sh</code>, which makes your project, then executes the app with the most verbose logging level.</em> Use it like this: </p>
<pre class="fragment">./debug_app.sh a1 [any other command-line arguments to pass to the app]
</pre><p>You can also enable logging on a per-file basis, which is <em>very</em> useful when targeting a specific bug. To do so, use a comma-separated list of file name globs, along with the logging level.</p>
<p>For example, to show debug messages from all Event* files and info messages from <a class="el" href="Component_8cpp.html">Component.cpp</a>, set the environment variables like this: </p>
<pre class="fragment">GLOG_vmodule='Event*=50,Component=40' ./watgui
</pre><p>Note the use of quotes (') to ensure the glob operator (*) is not interpreted by the shell. <em>Also note that the comma-separated list of files cannot have a space between items.</em></p>
<h2><a class="anchor" id="logging_marking"></a>
Logging Level for Assignment Marking</h2>
<p>To mark your application, we will execute it using the <code>mark_app.sh</code> shell script (included), which runs your application as: </p>
<pre class="fragment">GLOG_v=0 ./app_name
</pre><h2><a class="anchor" id="logging_scheme"></a>
Setting Logging Levels via Scheme</h2>
<p>We have also provided a number of functions to enable you to set logging levels at runtime via the Scheme interpreter. For example, to set to debug logging levels, you can use: </p>
<pre class="fragment">(logging-set-to-debug)
</pre><p>See similar logging routines in <code>cs349_init.scm</code>.</p>
<h1><a class="anchor" id="unit_tests"></a>
Unit Tests</h1>
<p>We have included a number of unit tests to help you test/verify your code, once you have made the necessary additions to the provided source code. We are using <a href="http://code.google.com/p/googletest/wiki/V1_7_Documentation">Google's unit testing framework</a> for testing.</p>
<p>Unit tests will be automatically built by the Makefile and output as a separate program called <code>x_unittests</code> where "x" will correspond to the app name (e.g., <code>a1_unittests</code>). Executing this will run the unit tests.</p>
<p>Included in the build is a file <a class="el" href="MarkingUnitTests_8cpp.html">MarkingUnitTests.cpp</a>. This file is empty and should remain so &ndash; it will be replaced by our own unit tests for marking purposes.</p>
<p>Writing a unit test is pretty straightforward. In a C++ file, create a new test using a TEST block: </p>
<pre class="fragment">TEST(test_case_name, test_name) {
 // test code
}
</pre><p>For example, a very simple test of the EventQueue object: </p>
<pre class="fragment">TEST(EventQueueTests, EventQueuing) {
  EventQueue eventQueue;
  EXPECT_EQ(0, eventQueue.GetNumEventsInQueue());
  MemoryTrackingEvent* event = new MemoryTrackingEvent();
  eventQueue.AddEventToQueue(event);
  EXPECT_EQ(1, eventQueue.GetNumEventsInQueue());
  delete event;
}
</pre><p>See the <a href="http://code.google.com/p/googletest/wiki/V1_7_Documentation">Google test documentation</a> or the included unit tests for more examples of how to write your own unit tests.</p>
<h2><a class="anchor" id="adding_unit_tests"></a>
Adding Unit Tests to the Build Process</h2>
<p>To add unit tests to the build process, add them in the section of the Makefile where indicated. They will be automatically linked in to the app and automatically added to all of the other tests (you don't need to explicitly register the tests with anything).</p>
<h1><a class="anchor" id="makefile"></a>
Makefile and Adding Files</h1>
<p>The Makefile is documented, and indicates where you should add files.</p>
<h1><a class="anchor" id="scheme"></a>
Scheme Interpreter</h1>
<p>The interpreter is a very slightly modified version of TinyScheme, which implements a subset of R5RS Scheme. A list of the Scheme commands built-in to the interpreter can be found in scheme/scheme_cmds.txt.</p>
<p>The goal of having the interpreter is to help you experiment with the GUI toolkit without needing to always write C/C++ code (thus avoiding compile and test cycles). Once you have implemented the missing parts of the toolkit, you should be able to perform many of the same GUI operations you would do in C++ using the Scheme interpreter.</p>
<p><em>You are not required to understand any of the code provided that is related to embedding the interpreter in the application. Nearly any file that starts with "Scheme" can be ignored by you.</em></p>
<p>That file <code>cs349_scheme_tests.scm</code> serves to document many of the functions available via the interpreter. <code>cs349_init.scm</code> provides more functions of interest and relevance to your work.</p>
<p>To execute any typed input, hit RETURN twice or press Ctrl-G. To quit the interpreter (and the app), press Ctrl-D.</p>
<p><b>Note</b>: If you application terminates in an unexpected manner and doesn't cleanly exit, the terminal can get a little unpredictable since the readline library didn't properly shut down. The effects of this are visible if you try to ssh into a remote host &ndash; after it asks for your password, it won't display anything else on the terminal. Note that this is not the only symptom of this problem &ndash; if things start getting a little weird and regular apps don't print out on the console as expected, you may need to start a new terminal.</p>
<p>The Scheme interpreter will try to run any files passed to the executable on the command line. For example, the following will execute the Scheme demo/test file: </p>
<pre class="fragment">./a1 cs349_scheme_tests.scm
</pre><p>To help debug Scheme scripts, you can turn tracing on/off while in the interpreter: </p>
<pre class="fragment">(tracing 1) ;; Turns tracing on
(tracing 0) ;; Turns tracing off
</pre><h1><a class="anchor" id="scheme_scripts"></a>
Adding Scheme Scripts</h1>
<p>You are free to add new Scheme scripts. You can add them to student-scripts.scm, which will be automatically loaded after all other scripts have been loaded. (It is loaded at the end of cs349_init.scm). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 9 2014 11:28:59 for CS349 WatGUI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
